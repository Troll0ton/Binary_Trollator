
# Бинарный Троллятор
## Содержание  
* [Аннотация](#annotation)  
* [Первая часть - JIT компилятор](#firstpart)  
	* [Trollessor](#trollessor)  
	* [IR](#int_repr)  
	* [X86-64](#x86-64)  
* [Вторая часть - AOT компилятор](#secondpart)  
	* [Техническая справка](#tech) 
* [Подведение итогов](#conc)

## Аннотация <a name="annotation"></a>

В данной работе представлена реализация бинарного транслятора, который позволяет произвести трансляцию машинного кода из **ISA** процессора **Trollessor** в код архитектуры набора команд **x86-64**.

В первой части проекта представлена реализация **JIT-компилятора**, подробно рассказано о трансляции поддерживаемых инструкций, о ряде концепций, примененных при разработке бинарного транслятора.

Вторая часть посвящена созданию и изучению строения собственного исполнимого и компонуемого файла (**ELF-format**), который получается из полученного при трансляции бинарного кода.

---

## Первая часть - JIT-компилятор <a name="firstpart"></a>

Перед тем как начинать процесс трансляции бинарного кода, нужно сказать пару слов о формате машинных команд процессора **Trollessor**. 

---

### Trollessor <a name="trollessor"></a> 

В первом семестре академического курса И. Р. Дединского "Введение в эмуляцию вычислительных систем, компиляторные технологии и промышленное программирование", мною был разработан собственный [виртуальный процессор](https://github.com/Troll0ton/Trollessor), с бинарного кода которого и будет производится трансляция.

Работа моего процессора, основана на принципе обратной польской записи, что позволяет производить все операции через внутренний стек виртуального процессора.
Машинная команда состоит из маски **кода операции**, занимающей 5 бит, и **маски-спецификатора** аргумента, состоящей из 3 бит. 

Все операции, поддерживаемые моим процессором, занумерованы и имеют соответствующие коды масок. **Маска-спецификатор** состоит из трех битовых флагов, показывающих, с каким типом аргумента работает текущая инструкция: регистр, память, константа. Данный процессор поддерживает работу с числами с плавающей запятой типа **double**.

После озвучивания информации о формате машинной команды виртуального процессора, перейдем к первому этапу проекта, процессу перевода бинарного кода в промежуточное представление (**IR**).

---

### IR <a name="int_repr"></a> 

Процесс бинарной трансляции включает в себя перевод бинарного кода в промежуточное представление, которое позволяет представить весь код, в виде некоторого набора таких записей.

Я решил реализовать данный процесс с помощью создания массива структур, в котором будут храниться вся информация об конкретной операции. Обработка исходного бинарного кода похожа на процесс его обработки виртуальным процессором.

Помимо банальной обработки инструкции и заполнения полей структур требовалось правильно обработать адресацию. С помощью двух обработок текущего кода, адрес изменился на номер той IR, на адрес инструкции которой изначально он ссылался. 

---

### X86-64 <a name="x86-64"></a> 

Когда получено представление кода в промежуточном виде, нетрудно перевести его в бинарный нужной архитектуры. Нужно построить логику работы каждой операции и заменить каждую запись в IR на набор соответствующих инструкций. Далее приведена трансляция всех поддерживаемых операций моего процессора:

#### HLT <a name="HLT"></a> 

#### PUSH <a name="PUSH"></a>

#### POP <a name="POP"></a>

#### Арифметические операции <a name="ARITHM"></a>

#### Безусловные и условные переходы <a name="JMPS"></a>

#### CALL <a name="CALL"></a>

#### RET <a name="RET"></a>

#### Стандартный ввод и вывод <a name="STDIO"></a>

#### DUMP <a name="DUMP"></a>


