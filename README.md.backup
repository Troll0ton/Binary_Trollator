
# Бинарный Троллятор
## Содержание  
* [Аннотация](#annotation)  
* [Первая часть - JIT компилятор](#firstpart)  
	* [Trollessor](#trollessor)  
	* [IR](#int_repr)  
	* [X86-64](#x86-64)
		* [PUSH](#PUSH) 
		* [POP](#POP) 
		* [Арифметические операции](#ARITHM)
		* [Безусловные и условные переходы](#JMPS) 
		* [CALL](#CALL) 
		* [RET](#RET) 
		* [HLT](#HLT) 
		* [Стандартный ввод и вывод](#STDIO)
	* [Ускорение](#speed)
* [Собственный ELF](#secondpart)  

## Аннотация <a name="annotation"></a>

В данной работе представлена реализация бинарного транслятора, который позволяет произвести трансляцию бинарного кода виртуального процессора **Trollessor** в нативный код архитектуры **x86-64**.

В первой части проекта представлена реализация **JIT-компилятора**, подробно рассказано о трансляции поддерживаемых инструкций, о ряде концепций, примененных при разработке бинарного транслятора.

Вторая часть посвящена созданию и изучению строения собственного исполнимого и компонуемого файла (**ELF-format**), который был получен при трансляции бинарного кода.

---

## Первая часть - JIT-компилятор <a name="firstpart"></a>

Перед тем как начинать процесс трансляции бинарного кода, нужно сказать пару слов о формате машинных команд процессора **Trollessor**. 

---

### Trollessor <a name="trollessor"></a> 

В первом семестре академического курса И. Р. Дединского "Введение в эмуляцию вычислительных систем, компиляторные технологии и промышленное программирование", мною был разработан собственный [виртуальный процессор](https://github.com/Troll0ton/Trollessor), с бинарного кода которого и будет производится трансляция.

Работа моего процессора, основана на принципе обратной польской записи, что позволяет производить все операции через внутренний стек виртуального процессора.
Машинная команда состоит из маски **кода операции**, занимающей 5 бит, и **маски-спецификатора** аргумента, состоящей из 3 бит. 

Все операции, поддерживаемые моим процессором, занумерованы и имеют соответствующие коды масок. **Маска-спецификатор** состоит из трех битовых флагов, показывающих, с каким типом аргумента работает текущая инструкция: регистр, память, константа. Данный процессор поддерживает работу с числами с плавающей запятой типа **double**.

После озвучивания информации о формате машинной команды виртуального процессора, перейдем к первому этапу проекта, процессу перевода бинарного кода в промежуточное представление (**IR**).

---

### IR <a name="int_repr"></a> 

Процесс бинарной трансляции включает в себя перевод бинарного кода в [промежуточное представление](https://en.wikipedia.org/wiki/Intermediate_representation), которое позволяет представить весь код, в виде некоторого набора таких записей.

Я решил реализовать данный процесс с помощью создания массива структур, в которых будет храниться вся информация об конкретной операции. Обработка исходного бинарного кода похожа на процесс его обработки виртуальным процессором.

```c++
typedef struct IR
{
    IR_node *buffer;
    int      size;
} IR;
```

```c++
typedef struct IR_node
{
    cmd_code command;
    int      imm_value;
    int      reg_num;
    char     ram_flag;
    int      troll_pos;
    char    *x64_pos;
} IR_node;
```

Помимо банальной обработки инструкции и заполнения полей структур требовалось правильно изменить адресацию. С помощью двух последовательных проходов по текущему коду, адрес изменился на номер той **IR_node**, на адрес инструкции которой изначально он ссылался. 

---

### X86-64 <a name="x86-64"></a> 

Когда получено представление кода в промежуточном виде, нетрудно перевести его в машинный требуемой архитектуры. Нужно построить логику работы каждой операции и заменить запись в IR на набор соответствующих инструкций. 

Далее приведена трансляция всех поддерживаемых операций моего процессора:

#### PUSH <a name="PUSH"></a>

Данная инструкция может оперировать с различными аргументами. Мы можем помещать в стек значение регистра, либо константное значение, либо значение определенной ячейки оперативной памяти.

```
PUSH reg + imm -> mov R13, imm 
                  add R13, reg
                  push R13
```

Отдельное внимание стоит уделить процессу трансляции операций, работающих с **оперативной памятью**. При запуске программы я помещаю в регистр **R12**указатель на выделенный заранее участок памяти. Значение данного регистра сохраняется на протяжении всей работы программы.

Когда операция пытается обратиться к **N**-ой ячейке оперативной памяти, фактически происходит обращение к **R12[N]** (эффективный адрес). Стоит отметить, что из-за того, что все значения хранятся в стеке в виде **double**, то и значение регистра будет в аналогичном формате. То есть при попытке обращения к **N**-ой ячейке, нужно перевести этот **N** в целочисленное представление. При этом изначально нужно сохранить значение регистра в стеке, чтобы **приведение типа** производилось только один раз.  

Также относительный адрес требуется умножить на 8, чтобы учесть размер типа, в котором хранятся значения в оперативной памяти.  

```
PUSH [reg + imm] -> mov R13, imm 
                    push reg
                    push reg
                    movsd xmm0, [rsp]
                    add rsp, 8
                    CVTTSD2SI reg, xmm0
                    add R13, reg
                    pop reg
                    shl R13, 3
                    add R13, R12
                    mov R13, [R13]
                    push R13
```


#### POP <a name="POP"></a>

Способ трансляции данной операции концептуально не отличается от **PUSH**, поэтому приведу лишь соответствующий набор инструкций архитектуры **x86-64**

```
POP reg -> pop reg
```

И операция с обращением к оперативной памяти соответственно:

```
POP [reg + imm] -> mov R13, imm 
                   push reg
                   push reg
                   movsd xmm0, [rsp]
                   add rsp, 8
                   CVTTSD2SI reg, xmm0
                   add R13, reg
                   pop reg
                   shl R13, 3
                   add R13, R12
                   movsd xmm0, [rsp]
                   add rsp, 8
                   movsd [r13], xmm0
```

Стоит отметить, что некоторые аргументы в приведенных операциях могут и отсутствовать. Допустимы перемещения в стек значения лишь регистров или констант. От этого не поменяется логика работы набора транслированных инструкций.

#### Арифметические операции <a name="ARITHM"></a>

Так как работа моего виртуального процессора основана на обратной польской записи, то было решено не менять концепцию и в конечном машинном коде архитектуры **x86-64**:

```
OP -> movsd xmm0, [rsp] 
      movsd xmm1, [rsp+8]
      OP xmm1, xmm0 (addsd, subsd, mulsd, divsd)
      add rsp, 8
      movsd [rsp], xmm1
      
```

Очевидно, что такой подход не является наиболее эффективным, так как при этом происходит лишнее обращение к памяти. Как избежать таких ситуаций, будет рассказано в разделе оптимизаций моего бинарного транслятора (такого раздела ещё нет **0_0** ).

#### Безусловные и условные переходы <a name="JMPS"></a>

Самым сложным в трансляции данных инструкций являлось правильное изменение адресации, логика которой аналогична ранее приведенному процессу в **IR**. 

Безусловный переход:

```
JMP -> jmp addr
      
```
И условный соответственно:

```
J__ -> movsd xmm0, [rsp] 
       movsd xmm1, [rsp+8]
       cmp xmm0, xmm1
       j__ addr
      
```

#### CALL <a name="CALL"></a>
```
CALL -> call addr
      
```
#### RET <a name="RET"></a>
```
RET -> ret
      
```
#### HLT <a name="HLT"></a>
Данная инструкция во много похожа на **RET**, но при этом требуется перед ней поместить адрес возврата, сохраненного в регистре **R10** в самом начале программы.
```
HLT -> push R10
       ret
```

#### Стандартный ввод и вывод <a name="STDIO"></a>
Стандартный ввод и вывод поддерживался в моем виртуальном процессоре с помощью команд **IN** и **OUT**, которые содержали в себе стандартные функции ввода и вывода.

Трансляция этих операций происходила следующим образом. Мною были написаны функции, которые использовали в себе стандартные функции ввода и вывода, при этом их аргументом являлся адрес (верхушка стека), с которым и оперировали команды.

```c++
void doublePrintf (double *value)
{
    printf("%0.1lf\n\n", *value);
}

void doubleScanf (double *value)
{
    scanf ("%lf", value);
}
```

Затем вызывались указанные мною функции, при этом сохранялись значения некоторых регистров. 

```
IN -> sub rsp, 8
      lea rdi, [rsp]
      call addr (doubleScanf)
```

```
OUT -> lea rdi, [rsp]
       call addr (doublePrintf)
       add rsp, 8
```

После завершения трансляции бинарного кода менялись права на исполнение буфера, в котором он лежал. После этого происходило его исполнение. 

### Ускорение <a name="speed"></a>

Теперь можно провести исследование, в котором можно сравнить скорость работы моего виртуального процессора и транслированного ранее кода. Чтобы влияние времени трансляции было минимальным, проверка происходила на вложенных циклах. В результате производительность была увеличена в приблизительно в **100 раз**. 

---

## Собственный ELF <a name="second_part"></a>

Следующей частью моего проекта стало создание собственного **ELF**, в котором и будет располагаться транслированный код. При этом требуется внести некоторые доработки в процесс трансляции, так как требуется правильно выделять место под оперативную память, производить печать.

С помощью библиотеки <elf.h>, которая позволяет работать с **ELF**-форматом в рамках структур языка C, были получены программные заголовки, заголовок самого файла.

Под оперативную память (**RAM**) была выделен отдельный сегмент, была переработана система адресации.

Было решено использовать ранее написанный **trolloprint**, в качестве стандартного вывода. Бинарный код данной функции помещался в отдельную секцию, что позволяло избежать трудностей с неправильной адресацией. 

После всех приготовлений записывался и ранее транслированный код, который также помещался в отдельную секцию.

---


